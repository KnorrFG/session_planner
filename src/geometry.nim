import tables, sets, strutils, sequtils, options, sugar, math, macros, strformat
import core


converter intToFloat64*(i: int): float64 = i.float64
converter pointToVec*[T](p: AbstractPoint[T]): (T, T) = (p.x, p.y)
converter iVecToFVec(x: (int, int)): (float64, float64) =
  (x[0].float64, x[1].float64)
converter pointSeqToVecSeq*[T](ps: seq[AbstractPoint[T]]): seq[(T, T)]=
  ps.map(pointToVec)
    

func initPoint*[T](x, y: T, name="", color: Color =colorsTable["schwarz"]):
    AbstractPoint[T] = AbstractPoint[T](name:name, x:x, y:y, color:color)


# This could be autogenerated by a macro
func set*[T, T2](p: AbstractPoint[T],
             name: string = p.name,
             x: T2 = T2(p.x),
             y: T2 = T2(p.y),
             color:Color = p.color):
  AbstractPoint[T2] = AbstractPoint[T2](name:name, x:x, y:y, color:color)


func `+`*[T](p: AbstractPoint[T], offset: T): AbstractPoint[T]=
  p + (offset, offset)


func `*`*[T](p: AbstractPoint[T], factor: T): AbstractPoint[T]=
  p.set(x = p.x * factor, y = p.y * factor)


func `+`*[T](p: AbstractPoint[T], offset: (T, T)): AbstractPoint[T]=
  p.set(x = p.x + offset[0], y = p.y + offset[1])
  

func `+`*[T](p: (T, T), offset: (T, T)): AbstractPoint[T]=
  (p[0] + offset[0], p[1] + offset[1])


func high[T2](T: typedesc[(T2, T2)]): T = (T2.high, T2.high)
func `-`[T](l:(T, T), r: (T, T)): (T, T) = (l[0] - r[0], l[1] - r[1])
func dot[T](l: (T, T), r: (T, T)): T = l[0] * r[0] + l[1] * r[1]
func abs[T](l: (T, T)): float64 = sqrt(float64(l[0] * l[0] + l[1] * l[1]))
func angle[T](l: (T, T), r: (T, T)): float64 =
  result = -arctan2(float64(l[0] * r[1] - l[1] * r[0]), float64(dot(l, r)))
  if result < 0:
    result += 2 * PI


func boundingRectSize[T](ps: seq[(T, T)]): (float64, float64)=
  let
    xs = ps.mapIt(it[0])
    ys = ps.mapIt(it[1])
    minX = min xs
    maxX = max xs
    minY = min ys
    maxY = max ys
  (maxX - minX, maxY - minY)


func rotate*[T](p: (T, T), a: float64): (float64, float64)=
  let 
    s = sin a
    c = cos a
  (p[0] * c - p[1] * s, p[0] * s + p[1] * c)


func findConvexHullStartPoint[T](points: seq[(T, T)]): (T, T)=
  ## reruns the left-top-most point
  func `<`(l: (T, T), r:(T, T)): bool=
    l[0] < r[0] or l[0] == r[0] and l[1] > r[1]
  min points


func findNextPointInConvexHull[T](p: (T, T), vecA: (T, T),
                                  points: seq[(T, T)]): (T, T)=
  # I know, this isnt exactly Memory efficient, but it doesn't matter here
  let 
    points =  points.filterIt(it != p)
    i = points.mapIt(angle(vecA, it - p)).minIndex()
  return points[i]


func findConvexHull[T: SomeNumber](points: seq[(T, T)]): seq[(T, T)]=
  case len points:
    of 0..2: raise newException(ValueError,
      "Cannot compute the convex hull of less than 3 points.")
    of 3:
      return points
    else:
      discard

  var 
    lastP = findConvexHullStartPoint points
    vec = (0.0, 1.0)
    nextP: (T, T)
  result.add lastP

  while true:
    nextP = findNextPointInConvexHull(lastP, vec, points)
    if nextP in result:
      break

    result.add(nextP)
    vec = nextP - lastP
    lastP = nextP


iterator slidingWindow2[T](xs: openArray[T]): (T, T)=
  for i in 0..<xs.high:
    yield (xs[i], xs[i + 1])


func rotateToDinA4*[T](ps: seq[(T, T)]): (seq[(T, T)], float64)=
  ## Returns the points rotated to fit DinA4 optimally, and the corresponding
  ## rotation angle
  var
    smallestArea = float64.high
    smallestW, smallestH: float64

  let hull = findConvexHull ps
  for (a, b) in slidingWindow2 hull:
    let 
      rotation = angle((1.0, 0.0), b - a) mod (0.5 * PI)
      rotatedPoints = ps.mapIt(rotate(it, rotation))
      (w, h) = boundingRectSize rotatedPoints
      area = w * h
    
    if area < smallestArea:
      smallestArea = area
      smallestW = w
      smallestH = h

      if smallestW > smallestH:
        result = (rotatedPoints.mapIt(rotate(it, 0.5*PI)), rotation + 0.5*PI)
      else:
        result = (rotatedPoints, rotation)


func normalizePoints*(ps: seq[Point], w, h, xOffset, yOffset: float64):
    seq[NormPoint]=
  ## Point coordinates are quite large, and assume 0, 0 at the left bottom
  ## This function recomputes them to be from 0 to (w, h) moved by the x and y
  ## offset and the origin at the top left

  if ps.len == 0:
    return
  if ps.len == 1:
    let p = ps[0]
    return @[initPoint(int(w / 2), int(h / 2), p.name, p.color)]

  let
    target_w = w * 0.8
    target_h = h * 0.8
    w_offset = int(w * 0.1)
    h_offset = int(h * 0.1)
    max_x = ps.mapIt(it.x).foldl(max(a, b))
    min_x = ps.mapIt(it.x).foldl(min(a, b))
    max_y = ps.mapIt(it.y).foldl(max(a, b))
    min_y = ps.mapIt(it.y).foldl(min(a, b))
    max_w = max_x - min_x
    max_h = max_y - min_y
    x_scale = target_w / max_w
    y_scale = target_h / max_h
    scale = min(x_scale, y_scale)
  ps.mapIt(NormPoint(name: it.name,
            x: int((it.x - min_x) * scale) + w_offset - xOffset.int,
            y: int((max_h - (it.y - min_y)) * scale) + h_offset - yOffset.int,
            color: it.color))


const eps = 1e-7
func `~=`(a: float, b: float): bool = abs(a - b) < eps
func `~=`(a: (float, float), b: (float, float)): bool =
  a[0] ~= b[0] and a[1] ~= b[1]


# there is a point type in core already, which will cause name collision, so
# for this Point, I just lazily prepend a G, and for coherence, I do it for
# Size and Rect too
type 
  GSize*[T] = object
    w*, h*: T
  GPoint*[T] = object
    x*, y*: T
  GRect*[T] = object
    x*, y*, w*, h*: T

func initGSize*[T](w, h: T): GSize[T] = GSize[T](w:w, h:h)
func initGPoint*[T](x, y: T): GPoint[T] = GPoint[T](x:x, y:y)
func initGRect*[T](x, y, w, h: T): GRect[T] = GRect[T](x:x, y:y, w:w, h:h)


when isMainModule:
  let 
    points = toHashSet(mapLiterals(
      [(0, 2), (2, 2), (2, 0), (0, 0), (1, 1), (1.1, 1.5)], float64))
    expResults = points.dup(excl((1.0, 1.0)), excl((1.1, 1.5)))
    res = findConvexHull toSeq points
  myAssert res == expResults

  myAssert angle((0, 1), (1, 0)) ~= 0.5 * PI
  myAssert rotate((1, 0), 0.5 * PI) ~= (0.0, 1.0) 
  myAssert rotate((1, 1), PI) ~= (-1.0, -1.0) 

